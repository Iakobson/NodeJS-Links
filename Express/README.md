# Express

_Здавалося б, навіщо нам потрібен додатковий фреймворк, якщо ми можемо скористатися готовим модулем http, який є у Node.js API. Однак Express сам використовує модуль http, але водночас надає ряд готових абстракцій, які спрощують створення сервера та серверної логіки, зокрема обробка відправлених форм, робота з куками, CORS тощо._

* Вихідний код фреймворку: https://github.com/expressjs/express
* Установка у проєкті: `npm install express`

- - -

Для використання Express на початку треба створити об'єкт, який представлятиме додаток:
```javascript
  const app = express();
```

Для обробки запитів Express визначено ряд вбудованих функцій, і однією з таких є `app.get()`. Вона обробляє GET-запити протоколу HTTP та дозволяє пов'язати маршрути з певними обробниками. Для цього першим параметром передається маршрут, а другим - обробник, який буде викликатись, якщо запит до сервера відповідає даному маршруту.

```javascript
  app.get("/", function(request, response){     
      // відправляємо відповідь
      response.send("<h2>Привіт від Express!</h2>");
  });
```

> _І що важливо, Express спирається на систему маршрутів, тому всі інші запити, які не відповідають кореневому маршруту "/", не будуть оброблятися._

- - -

## Конвеєр обробки запиту та middleware

_Коли фреймворк Express отримує запит, цей запит передається до конвеєра обробки. Конвеєр складається з набору компонентів або middleware, які отримують дані запиту та вирішують, як його обробляти._

При необхідності ми можемо вбудувати конвеєр обробки запиту на будь-якому етапі будь-яку функцію middleware. Для цього використовується метод `app.use()`.

```javascript
  app.use(function(request, response, next){    
    console.log("виконується Middleware 1");
    next();
  });
```

Middleware допомагають виконувати деякі завдання, які мають бути зроблені до надсилання відповіді.\
Стандартне завдання – логування запитів.

```javascript
  // цей middleware виконується кожного разу при http-запиті
  app.use(function(request, response, next){     
    let now = new Date();
    let hour = now.getHours();
    let minutes = now.getMinutes();
    let seconds = now.getSeconds();
    let data = `${hour}:${minutes}:${seconds} ${request.method} ${request.url} ${request.get("user-agent")}`;
    console.log(data);
    fs.appendFile("server.log", data + "\n", function(){});
    next();
  });
```

## Надсилання відповіді

_Для надсилання відповіді в express у об'єкта response можна використовувати низку функцій. Найпоширеніший спосіб надсилання відповіді представляє функція `send()`. Як параметр ця функція може приймати об'єкт Buffer, рядок, у тому числі з html-кодом, об'єкт javascript або масив._

```javascript
  app.get("/", function(request, response){
     console.log("відбувся перехід на /");
      // відправляємо відповідь
	  response.sendFile(__dirname + "/views/index.html");
  });
```

Функція ``sendStatus()`` надсилає користувачеві певний статусний код з деяким стандартним повідомленням.

```javascript
  app.use("/home/foo/",function (request, response) {
      response.status(404).send(`Такий ресурс не знайдено`);
  });
```

### Статичні файли

У випадку ``app.use(express.static(__dirname + "/public"));`` ми безпосередньо звертаємося до статичних файлів, а функція ``sendFile`` фактично бере вміст із файлу та відсилає його користувачеві.

```javascript
    app.use("/static", express.static(__dirname + "/views"));

  // http://localhost:5000/static/about.html
```

- - -

## Маршрутизація

_Під час обробки запитів фреймворк Express спирається на систему маршрутизації. У додатку визначаються маршрути та обробники цих маршрутів. Якщо запит відповідає певному маршруту, викликається для обробки запиту відповідний обробник._

Як перший параметр ці функції можуть приймати шаблон адреси, запит за яким оброблятиметься. Другий параметр функцій представляє функцію, яка буде обробляти запит за адресою, що збіглася з шаблоном.

> Шаблони адрес, що використовуються, можуть містити регулярні вирази або спеціальні символи підстановок.
* `?` вказує, що попередній символ може зустрічатися 1 раз або відсутній
  + app.get("/bo?k", function (request, response)
    - маршрут буде відповідати рядку запиту "/bk" або "/bok"
* `+` вказує, що попередній символ може зустрічатися 1 і більше разів
  + app.get("/bo+k", function (request, response)
    - маршрут відповідатиме запитам "/bok", "/book", "/booоk"
* `*` вказує, що на місці даного символу може бути будь-яка кількість символів
  + app.get("/bo*k", function (request, response)
    - маршрут відповідатиме запитам "/bork", "/bonk", "/bor.dak", "/bor/ok" і так далі
* `()` дозволяють оформити групу символів, які можуть зустрічатися у запиті
  + app.get("/book(.html)?", function (request, response)
    - вказує, що ".html" може зустрічатися або бути відсутнім в рядку запиту.

#### Передача даних програмі. Параметри рядка запиту

> Рядок запиту (query) - це частина запитаної адреси, яка йде після знака питання.

Приклад: 
```javascript
  app.use("/users", function(request, response){      
    let id = request.query.id;
    let userName = request.query.name;
    response.send("<h1>Дані про користувача:</h1><p>id=" + id +"</p><p>name=" + userName + "</p>");
  });

  // http://localhost:5000/users?id=37&name=Tome
```

Під час передачі у рядку запиту **властивості об'єкта** поміщаються у квадратні дужки: user[id].

### Переадресация

_Як параметр path передається шлях, на який буде перенаправлятися користувач. Додатковий параметр status визначає статусний код переадресації. Якщо цей параметр не заданий, тоді за умовчанням надсилається статусний код 302, який передбачає часову переадресацію._

За допомогою даного методу можна виконувати переадресацію як відносними шляхами, так і абсолютними, в тому числі на інші домени.

```javascript
  // робимо переадресацію на іншу адресу
  app.use("/home",function (request, response) {
    response.redirect("about")
  });
```

- - -

## POST-запити та відправлення форм

Насамперед для отримання відправлених даних необхідно створити парсер:

```javascript
  // створюємо парсер для даних application/x-www-form-urlencoded
  const urlencodedParser = express.urlencoded({extended: false});
  
  app.get("/userform", function (request, response) {
    response.sendFile(__dirname + "/views/formpost.html");
  });
  app.post("/userform", urlencodedParser, function (request, response) {
    if(!request.body) return response.sendStatus(400);
    console.log(request.body);
    response.send(`${request.body.userName} - ${request.body.userAge}`);
  });

  // http://localhost:5000/userform
```

> Оскільки дані відправляються за допомогою форми, то для створення парсера використовується функція `urlencoded()`. У цю функцію передається об'єкт, що встановлює параметри парсингу. Значення `extended: false` вказує на те, що об'єкт - результат парсингу буде представляти набір пар ключ-значення, а кожне значення може бути представлене у вигляді рядка або масиву.










