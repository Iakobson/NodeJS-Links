# EventEmitter
> > _Більшість функціоналу Node.js застосовує асинхронну архітектуру подій, яка використовує спеціальні об'єкти - емітери для генерації різних подій, які обробляються спеціальними функціями - обробниками або слухачами подій._
> > _Всі об'єкти, що генерують події, представляють екземпляри класу EventEmitter._

### Основні методи та функції, пов'язані з EventEmitter, включають:

* ``on(event, listener)`` або ``addListener(event, listener)``:
  + Додає обробник подій listener для події event.
  + Коли подія event відбудеться, обробник listener буде викликаний.
* ``once(event, listener)``:
  + Додає обробник подій listener, який буде викликаний лише один раз при настанні події event.
  + Після цього обробник буде автоматично видалений.
* ``emit(event, [arg1], [arg2], [...])``:
  + Генерує подію event та передає аргументи обробникам, які підписані на цю подію.
* ``removeListener(event, listener)``:
  + Видаляє обробник listener з події event.
* ``removeAllListeners([event])``:
  + Видаляє всі обробники подій або всі обробники для конкретної події event.
* ``listeners(event)``:
  + Повертає масив обробників для певної події event.
* ``setMaxListeners(n)``:
  + Задає максимальну кількість обробників, які можуть бути підписані на одну подію.
  + За замовчуванням максимальна кількість - 10.

Ви можете використовувати його для створення власних об'єктів, які видають та обробляють події у вашому програмному коді. Це корисно для реалізації асинхронних операцій, взаємодії компонентів програми та багатьох інших сценаріїв.

```javascript
// eventEmitter.js
// Цей код демонструє створення та реагування на події. 
// дозволяє створювати об'єкти, які можуть генерувати події та реагувати на них
const Emitter = require("events");
let emitter = new Emitter();

// визначаємо назву події, яка буде використовуватися для спрацьовування та підписки на неї
let event1Name = "greet1";
let event2Name = "greet2";

class User extends Emitter {
  // об'єкти, створені з цього класу, будуть мати можливість генерувати та обробляти події
    sayHi(data) {
        this.emit(event2Name, data);
    }
}

let user = new User();


emitter.on(event1Name, function(){
    console.log("Привітики!");
});
 
emitter.on(event1Name, function(){
    console.log("Чудова погода!");
});
 
emitter.on(event2Name, function(data){
    console.log(data);
}); 

// додаємо до нього обробку події
user.on(event2Name, function(data){
    console.log(data);
}); 


// Генерація подій "greet":
emitter.emit(event1Name);
  // =>> Привітики! Чудова погода!

emitter.emit(event2Name, "Радий вас бачити!");
  // =>> Радий вас бачити!

user.sayHi("Мені потрібний твій одяг...");
```

### Stream
> _В Node.js, стріми (streams) - це потоки даних, які дозволяють зчитувати або записувати дані послідовно частинами (чанками), а не завантажувати всі дані одразу в пам'ять. Використання стрімів дозволяє ефективно обробляти великі обсяги даних або робити операції в реальному часі без перевищення ліміту пам'яті._

**Node.js надає чотири основних типи стрімів:**
+ Readable Stream (Читаючий стрім):
  - Цей тип стріму використовується для читання даних.
  - Він надає можливість поетапно зчитувати дані, наприклад, з файлу, мережі або іншого джерела.
+ Writable Stream (Записуючий стрім):
  - Використовується для запису даних.
  - Ви можете записувати дані у стрім частинами, наприклад, у файл або на сервер.
+ Duplex Stream (Двосторонній стрім):
  - Цей стрім комбінує можливості читаючого і записуючого стріму, тобто ви можете одночасно читати та записувати дані.
+ Transform Stream (Трансформуючий стрім):
  - Використовується для зміни даних, коли вони переходять з одного стріму в інший.
  - Це дозволяє здійснювати операції, такі як фільтрація, обрізка, обробка тощо.

**Основні методи та події для роботи зі стрімами в Node.js включають:**
+ ``pipe(destination)``:
  - Метод для спрощеного керування потоком даних між стрімами.
  - Використовується для автоматичного пересилання даних з одного стріму в інший.
+ ``readable.on('data', callback)``:
  - Подія для читаючих стрімів, що спрацьовує при зчитуванні нового чанка даних.
  - Callback-функція отримує чанк даних як аргумент.
+ ``writable.write(data)``:
  - Метод для записуючих стрімів, що використовується для запису чанку даних до стріму.
+ ``writable.end()``:
  - Метод для записуючих стрімів, який позначає завершення потоку даних.
+ ``readable.pipe(writable)``:
  - Метод для спрощеного пересилання даних з читаючого стріму до записуючого стріму.
+ ``transform._transform(chunk, encoding, callback)``:
  - Метод для трансформуючих стрімів, який викликається для обробки кожного чанку даних.
+ ``finish``:
  - Подія, яка спрацьовує, коли записуючий стрім завершує запис.
+ ``error``:
  - Подія, яка спрацьовує, якщо виникає помилка у стрімі.











